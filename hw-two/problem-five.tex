\documentclass[12pt]{article}
\usepackage{fullpage}
\usepackage{titlesec}
\usepackage{tikz}
\usepackage{amsfonts,amssymb}
\usepackage{amsmath}
\usepackage{comment}
\relpenalty=9999
\binoppenalty=9999

\begin{document}
\pagestyle{plain}
\titleformat{\subsection}[runin]
  {\normalfont\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}[runin]
  {\normalfont\large\bfseries}{\thesubsubsection}{1em}{}

\section*{Problem 5a.}
\textbf{Theorem:} The function $M(x)$ is well-defined for all $x\in\{0,1\}^+$
(non-empty strings).
\newline
\textbf{Proof:} By straightforward induction on the length of $x$. In the base
case $|x| = 1$ therefore $x = 0$ or $x = 1$ where both $M(0)$ and $M(1)$ are
well-defined. In the inductive case we can write $x$ as $x = x'y$ where
$|x'| = n-1$ and $y\in \{0,1\}$. Then $M(x) = M(x'y) = M(x') \times M(y)$ by
definition where $M(y) = M(0) \text{ or } M(1)$ are both well-defined and
$M(x')$ is well-defined by the induction hypothesis. Thus, $M(x)$ is the product
of two $2 \times 2$ matrices which is well-defined.
\vspace{2mm}
\newline
\textbf{Theorem:} $M(x) = M(y) \Rightarrow x = y$.
\newline
\textbf{Proof:} First we define the inverse map function $M^{-1}(x)$ for
$x \in \{0,1\}$ as
$$M^{-1}(0) = \left(\begin{array}{cc} 1 & 0 \\ -1 & 1 \end{array}\right)
\text{ and } M^{-1}(1) = \left(\begin{array}{cc} 1 & -1 \\ 0 & 1 \end{array}\right)$$
Such that $M(x\cdot0)\times M^{-1}(0) = M(x)$ and $M(x\cdot1)\times M^{-1}(1) = M(x)$
by the associativity of multiplication and the definition of an inverse matrix.
Now, given a bit string $x$ we can uniquely determine that last bit that was used
to construct $M(x)$. Let $x = x'y$ such that $|x| \ge 0$ and $y\in\{0,1\}$. Then
$M(x) = M(x'y) = M(x') \times M(y)$ where 
$$M(x') \times M(0) =
\left(\begin{array}{cc} a & b \\ c & d \end{array}\right) \times
\left(\begin{array}{cc} 1 & 0 \\ 1 & 1 \end{array}\right) =
\left(\begin{array}{cc} a+b & b \\ c+d & d \end{array}\right)$$
$$M(x') \times M(1) =
\left(\begin{array}{cc} a & b \\ c & d \end{array}\right) \times
\left(\begin{array}{cc} 1 & 1 \\ 0 & 1 \end{array}\right) =
\left(\begin{array}{cc} a & a+b \\ c & c+d \end{array}\right)$$
We see that if for a matrix of the form 
$\left(\begin{array}{cc} a' & b' \\ c' & d' \end{array}\right)$ that if
$a' \ge b'$ and $c' \ge d'$ then the last bit in $x$ was a $0$ and if
the opposite occurs, $b' \ge a'$ and $d' \ge c'$ then the last bit $x$ was
a $1$. The proof that both these events cannot occur simultaneously is by
straightforward induction on the input $x$ where the base case is immediate and
the inductive case is shown by the fact that in either case one side of the
matrix remains constant while the other side increases specifically related
to whether or not the last bit was a $0$ or $1$. Since this is the case we can
then perform the following algorithm to generate a unique input string $x$ given
a matrix $M(x)$: Uniquely determine whether the last bit used to generate $M(x)$
was a $0$ or $1$ and record this concatenated with the string generated by
performing the algorithm on the matrix $M(x'y)M^{-1}(y) = M(x')$ where $y$ is
the unqiue $0/1$ bit at the end of $x$. Since each bit in the output is determined
uniquely, only one input string could generate the given output matrix therefore
the mapping function is injective.
\vspace{2mm}
\newline
\textbf{Theorem:} For every $x \in \{0,1\}^n$, the entries of $M(x)$ are bounded
by Fibonacci number $F_n$.
\newline
\textbf{Proof:} By straightforward induction on $n$. In the base case $n = 1$ so
$x = 0$ or $x = 1$ where the entries of $M(0)$ and $M(1)$ are bound by $F_1 = 1$.
In the inductive case, $x = x'y$ where $|x'| = n-1$ and $y \in \{0,1\}$. Let
$$M(x') = \left(\begin{array}{cc} a & b \\ c & d \end{array}\right)$$
The entries in $M(x')$ are bound by the Fibonacci number $F_{n-1}$ by the
induction hypothesis. Then we have
$M(x) = M(x'y) = M(x') \times M(y)$ with $y\in \{0,1\}$ so we have
$$M(x') \times M(0) =
\left(\begin{array}{cc} a & b \\ c & d \end{array}\right) \times
\left(\begin{array}{cc} 1 & 0 \\ 1 & 1 \end{array}\right) =
\left(\begin{array}{cc} a+b & b \\ c+d & d \end{array}\right)$$
$$M(x') \times M(1) =
\left(\begin{array}{cc} a & b \\ c & d \end{array}\right) \times
\left(\begin{array}{cc} 1 & 1 \\ 0 & 1 \end{array}\right) =
\left(\begin{array}{cc} a & a+b \\ c & c+d \end{array}\right)$$
By the induction hypothesis the $a,b,c, \text{ and } d$ entries are bound by
$F_{n-1}$ so they are also bound by $F_n$. To show that $a+b$ and $c+d$ entries
are also bound by $F_n$ we can see that either $a$ or $b$ and either $c$ or $d$
remain unchanged when a binary string is concatenated with either $0$ or $1$.
By the induction hypothesis, in step $n-2$, $a, b, c, \text{ and } d$ were bound
by $F_{n-2}$ and in the $n-1$ step either $a \text{ and } c \text{ or }
b \text{ and } d$ remained unchanged and thus remained bound by $F_{n-2}$.
Therefore $a+b$ and $c+d$ are bound by $F_{n-1} + F_{n-2}$ which means they are
also bound by $F_n = F_{n-1} + F_{n-2}$.

\section*{Problem 5b.}
Consider the following randomized algorithm for pattern matching problem
described in the problem statement. Select a prime $p$ from the range $[1...T]$
where $T$ will be determined later. Compute $M(y)\mod p$ in $O(m)$ time. Now
for each consequetive substring of length $m$ in $x$, call it $x'$, compute
$M(x')\mod p$. There are at most $n$ such substrings. We can compute all
$n$ of these $M(x')$ in $O(n)$ time by observing that each substring differs in
only the first and last bit. So if we have two consequetive substrings $x'_1$
and $x'_2$ then $x'_1 = yx'$ and $x'_2 = x'z$ where $y,z\in\{0,1\}$. Then
we can compute $M(x'_2)$ from $M(x'_1)$ by using the inverse functions defined
above in the following way: $M(x'_2) = M^{-1}(y)\cdot M(x'_1)\cdot M(z)$. Since
each of those operations can be done in constant time and we perform it for each
$m$ length substring of $x$ we can get all the value modulo p in $O(n)$ time
total. Then we compare the fingerprint of $y$ to the fingerprint of each
substring of $x$ and if any of them match return YES otherwise return NO. In
the case where $y$ is in fact a substring $x$ we always return YES correctly. But
we may err on the side where $y$ is not a substring of $x$ but we return YES
anyways. 


\end{document}
